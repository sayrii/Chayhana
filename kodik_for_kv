import sys
import os
import sqlite3
from dataclasses import dataclass
from typing import List, Optional

from PyQt6 import QtWidgets, QtCore, QtGui
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QLabel, QCheckBox, QPushButton, QScrollArea,
                             QMessageBox, QFileDialog, QComboBox, QTableWidget,
                             QTableWidgetItem, QHeaderView, QDialog, QTabWidget,
                             QStatusBar, QMenuBar, QMenu, QApplication)


@dataclass
class Dish:
    """класс, который будет представлять блюдо"""
    id: int
    name: str
    price: float
    image_path: str
    description: str
    category: str
    is_selected: bool = False


class Order:
    """а тут класс для управления заказом"""

    def __init__(self):
        self.selected_dishes: List[Dish] = []

    def add_dish(self, dish: Dish) -> None:
        """возможность добавить блюдо в заказ"""
        if dish not in self.selected_dishes:
            self.selected_dishes.append(dish)

    def remove_dish(self, dish: Dish) -> None:
        """возможность удалить блюдо из заказа"""
        if dish in self.selected_dishes:
            self.selected_dishes.remove(dish)

    def clear_order(self) -> None:
        """кнопочка очистить заказ"""
        self.selected_dishes.clear()

    def get_total_price(self) -> float:
        """получить общую стоимость заказа"""
        return sum(dish.price for dish in self.selected_dishes)

    def get_dish_count(self) -> int:
        """получить количество выбранных блюд"""
        return len(self.selected_dishes)


class MenuManager:
    """менеджер для работы с меню))"""

    def __init__(self):
        self.dishes: List[Dish] = []

    def load_dishes_from_database(self, database) -> None:
        """загрузить блюда из базы данных"""
        self.dishes = database.get_all_dishes()

    def get_dishes_by_category(self, category: str) -> List[Dish]:
        """получить блюда по категории"""
        return [dish for dish in self.dishes if dish.category == category]

    def get_categories(self) -> List[str]:
        """получить список категорий"""
        return list(set(dish.category for dish in self.dishes))

    def find_dish_by_id(self, dish_id: int) -> Optional[Dish]:
        """найти блюдо по айдишке"""
        for dish in self.dishes:
            if dish.id == dish_id:
                return dish
        return None


class DatabaseManager:
    """менеджер базы данных для приложения"""

    def __init__(self, db_path: str = "restaurant.db"):
        self.db_path = db_path
        self._init_database()

    def _init_database(self) -> None:
        """инициализировать базу данных и создать таблицы"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # тут таблица категорий
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS categories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    description TEXT
                )
            ''')

            # это таблица блюд
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS dishes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    price REAL NOT NULL,
                    image_path TEXT,
                    description TEXT,
                    category_id INTEGER,
                    FOREIGN KEY (category_id) REFERENCES categories (id)
                )
            ''')

            # это таблица заказов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    total_price REAL NOT NULL,
                    status TEXT DEFAULT 'pending'
                )
            ''')

            # это таблица элементов заказа
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS order_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id INTEGER,
                    dish_id INTEGER,
                    quantity INTEGER DEFAULT 1,
                    price REAL NOT NULL,
                    FOREIGN KEY (order_id) REFERENCES orders (id),
                    FOREIGN KEY (dish_id) REFERENCES dishes (id)
                )
            ''')

            self._insert_sample_data(cursor)

            conn.commit()

    def _insert_sample_data(self, cursor: sqlite3.Cursor) -> None:
        """Вставить тестовые данные в базу"""

        # тут мы проверяем есть ли уже категории
        cursor.execute("SELECT COUNT(*) FROM categories")
        if cursor.fetchone()[0] == 0:
            categories = [
                ("Основные блюда", "Сытные и питательные блюда"),
                ("Салаты", "Свежие и легкие салаты"),
                ("Напитки", "Освежающие напитки")
            ]
            cursor.executemany(
                "INSERT INTO categories (name, description) VALUES (?, ?)",
                categories
            )

        # а тут проверяем есть ли уже блюда
        cursor.execute("SELECT COUNT(*) FROM dishes")
        if cursor.fetchone()[0] == 0:
            dishes = [
                ("Стейк Рибай", 25.99, "Премиальный стейк с овощами", 1),
                ("Паста Карбонара", 18.50, "Классическая итальянская паста", 1),
                ("Греческий салат", 12.75, "Свежие овощи с фетой", 2),
                ("Цезарь с курицей", 14.25, "Салат Цезарь с куриной грудкой", 2),
                ("Апельсиновый сок", 5.50, "Свежевыжатый апельсиновый сок", 3),
                ("Кофе Латте", 4.75, "Ароматный кофе с молоком", 3)
            ]
            cursor.executemany(
                "INSERT INTO dishes (name, price, image_path, description, category_id) VALUES (?, ?, ?, ?, ?)",
                dishes
            )

    def get_all_dishes(self) -> List[Dish]:
        """Получить все блюда из базы данных"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT d.id, d.name, d.price, d.image_path, d.description, c.name 
                FROM dishes d 
                JOIN categories c ON d.category_id = c.id
            ''')

            dishes = []
            for row in cursor.fetchall():
                dish = Dish(
                    id=row[0],
                    name=row[1],
                    price=row[2],
                    image_path=row[3],
                    description=row[4],
                    category=row[5]
                )
                dishes.append(dish)

            return dishes

    def save_order(self, dishes: List[Dish], total_price: float) -> int:
        """Сохранить заказ в базу данных и вернуть ID заказа"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # здесь вставляем основной заказ
            cursor.execute(
                "INSERT INTO orders (total_price) VALUES (?)",
                (total_price,)
            )
            order_id = cursor.lastrowid

            # а тут вставляем элементы заказа
            order_items = [(order_id, dish.id, 1, dish.price) for dish in dishes]
            cursor.executemany(
                "INSERT INTO order_items (order_id, dish_id, quantity, price) VALUES (?, ?, ?, ?)",
                order_items
            )

            conn.commit()
            return order_id

    def get_order_history(self) -> List[dict]:
        """получить историю заказов"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT o.id, o.order_date, o.total_price, o.status,
                       COUNT(oi.id) as item_count
                FROM orders o
                LEFT JOIN order_items oi ON o.id = oi.order_id
                GROUP BY o.id
                ORDER BY o.order_date DESC
            ''')

            orders = []
            for row in cursor.fetchall():
                orders.append({
                    'id': row[0],
                    'date': row[1],
                    'total_price': row[2],
                    'status': row[3],
                    'item_count': row[4]
                })

            return orders


class DishWidget(QWidget):
    """виджет для отображения блюда"""

    selection_changed = pyqtSignal(int, bool)  # dish_id, is_selected

    def __init__(self, dish: Dish, parent=None):
        super().__init__(parent)
        self.dish = dish
        self._init_ui()

    def _init_ui(self) -> None:
        """инициализировать пользовательский интерфейс"""
        main_layout = QHBoxLayout(self)

        # чекбокс для выбора блюда
        self.checkbox = QCheckBox()
        self.checkbox.setChecked(self.dish.is_selected)
        self.checkbox.stateChanged.connect(self._on_checkbox_changed)
        main_layout.addWidget(self.checkbox)

        image_container = QWidget()
        image_container.setFixedSize(100, 100)
        image_layout = QVBoxLayout(image_container)

        color_label = QLabel()
        color_label.setFixedSize(80, 80)

        # разные цвета для разных блюд
        colors = ['#FFE4E1', '#E6E6FA', '#F0FFF0', '#FFF0F5', '#F5F5DC', '#F0F8FF']
        color_index = hash(self.dish.name) % len(colors)
        color_label.setStyleSheet(f"background-color: {colors[color_index]}; border: 1px solid #ccc;")
        color_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        color_label.setText(self.dish.name[:10] + "..." if len(self.dish.name) > 10 else self.dish.name)

        image_layout.addWidget(color_label)
        main_layout.addWidget(image_container)

        # информация о блюде
        info_layout = QVBoxLayout()

        name_label = QLabel(self.dish.name)
        name_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        info_layout.addWidget(name_label)

        desc_label = QLabel(self.dish.description)
        desc_label.setStyleSheet("color: gray; font-size: 12px;")
        desc_label.setWordWrap(True)
        info_layout.addWidget(desc_label)

        price_label = QLabel(f"Цена: {self.dish.price:.2f} руб.")
        price_label.setStyleSheet("color: green; font-weight: bold; font-size: 12px;")
        info_layout.addWidget(price_label)

        info_layout.addStretch()
        main_layout.addLayout(info_layout)

        self.setLayout(main_layout)
        self.setFixedHeight(120)
        self.setStyleSheet("""
            DishWidget {
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 5px;
                margin: 2px;
                background-color: white;
            }
            DishWidget:hover {
                background-color: #f5f5f5;
            }
        """)

    def _on_checkbox_changed(self, state: int) -> None:
        """ообработчик изменения состояния чекбокса"""
        is_checked = state == Qt.CheckState.Checked.value
        self.dish.is_selected = is_checked
        self.selection_changed.emit(self.dish.id, is_checked)


class OrderDialog(QDialog):
    """диалоговое окно подтверждения заказа"""

    def __init__(self, order: Order, parent=None):
        super().__init__(parent)
        self.order = order
        self._init_ui()

    def _init_ui(self) -> None:
        """инициализировать пользовательский интерфейс"""
        self.setWindowTitle("Подтверждение заказа")
        self.setFixedSize(400, 300)

        layout = QVBoxLayout(self)

        # заголовок
        title_label = QLabel("Ваш заказ:")
        title_label.setStyleSheet("font-weight: bold; font-size: 16px;")
        layout.addWidget(title_label)

        # список выбранных блюд
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)

        for dish in self.order.selected_dishes:
            dish_layout = QHBoxLayout()
            dish_layout.addWidget(QLabel(f"• {dish.name}"))
            dish_layout.addStretch()
            dish_layout.addWidget(QLabel(f"{dish.price:.2f} руб."))
            scroll_layout.addLayout(dish_layout)

        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        layout.addWidget(scroll_area)

        # итоговая сумма
        total_layout = QHBoxLayout()
        total_layout.addWidget(QLabel("Итого:"))
        total_layout.addStretch()
        total_label = QLabel(f"{self.order.get_total_price():.2f} руб.")
        total_label.setStyleSheet("font-weight: bold; color: green;")
        total_layout.addWidget(total_label)
        layout.addLayout(total_layout)

        # кнопочкi
        button_layout = QHBoxLayout()

        cancel_button = QPushButton("Отмена")
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)

        confirm_button = QPushButton("Подтвердить")
        confirm_button.clicked.connect(self.accept)
        confirm_button.setStyleSheet("background-color: #4CAF50; color: white;")
        button_layout.addWidget(confirm_button)

        layout.addLayout(button_layout)
        self.setLayout(layout)


class MainWindow(QMainWindow):
    """главное окно приложения"""

    def __init__(self):
        super().__init__()
        self.database = DatabaseManager()
        self.menu_manager = MenuManager()
        self.order = Order()

        self._init_ui()
        self._load_data()
        self._connect_signals()

    def _init_ui(self) -> None:
        """инициализировать пользовательский интерфейс"""
        self.setWindowTitle("Ресторан - Система заказов")
        self.resize(900, 700)

        # центральный виджет
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # главный layout
        main_layout = QVBoxLayout(central_widget)

        # создаем вкладки
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)

        # вкладка меню
        self.menu_tab = QWidget()
        self.tab_widget.addTab(self.menu_tab, "Меню")
        self._setup_menu_tab()

        # вкладка истории заказов
        self.history_tab = QWidget()
        self.tab_widget.addTab(self.history_tab, "История заказов")
        self._setup_history_tab()

        # создаем меню
        self._create_menu()

        # статус бар
        self.statusbar = QStatusBar()
        self.setStatusBar(self.statusbar)
        self.statusbar.showMessage("Готово к работе")

    def _setup_menu_tab(self) -> None:
        """настроить вкладку меню"""
        layout = QVBoxLayout(self.menu_tab)

        # комбобокс категорий
        self.category_combo = QComboBox()
        layout.addWidget(self.category_combo)

        # 0бласть прокрутки для блюд
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_widget = QWidget()
        self.dishes_layout = QVBoxLayout(self.scroll_widget)
        self.scroll_area.setWidget(self.scroll_widget)
        layout.addWidget(self.scroll_area)

        # панель управления
        control_layout = QHBoxLayout()

        self.clear_button = QPushButton("Очистить выбор")
        control_layout.addWidget(self.clear_button)

        control_layout.addStretch()

        self.total_label = QLabel("Итого: 0.00 руб.")
        control_layout.addWidget(self.total_label)

        self.confirm_button = QPushButton("Подтвердить заказ")
        control_layout.addWidget(self.confirm_button)

        layout.addLayout(control_layout)

    def _setup_history_tab(self) -> None:
        """настроить вкладку истории заказов"""
        layout = QVBoxLayout(self.history_tab)

        # тут таблица заказов
        self.orders_table = QTableWidget()
        self._setup_orders_table()
        layout.addWidget(self.orders_table)

        # а тут кнопка обновления
        self.refresh_button = QPushButton("Обновить")
        layout.addWidget(self.refresh_button)

    def _setup_orders_table(self) -> None:
        """настроить таблицу истории заказов"""
        self.orders_table.setColumnCount(5)
        self.orders_table.setHorizontalHeaderLabels([
            "ID", "Дата", "Кол-во блюд", "Сумма", "Статус"
        ])
        self.orders_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

    def _create_menu(self) -> None:
        """а тут создать меню приложения"""
        menubar = QMenuBar(self)
        self.setMenuBar(menubar)

        # а тут меню файл
        file_menu = menubar.addMenu("Файл")

        self.export_action = QtGui.QAction("Экспорт заказов", self)
        file_menu.addAction(self.export_action)

        self.exit_action = QtGui.QAction("Выход", self)
        file_menu.addAction(self.exit_action)

        # а здесь меню Справка
        help_menu = menubar.addMenu("Справка")

        self.about_action = QtGui.QAction("О программе", self)
        help_menu.addAction(self.about_action)

    def _load_data(self) -> None:
        """загрузить данные из базы"""
        try:
            self.menu_manager.load_dishes_from_database(self.database)
            self._populate_categories()
            self._show_dishes()
            self._load_order_history()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось загрузить данные: {str(e)}")

    def _populate_categories(self) -> None:
        """заполнить комбобокс категориями"""
        self.category_combo.clear()
        self.category_combo.addItem("Все категории")

        for category in self.menu_manager.get_categories():
            self.category_combo.addItem(category)

    def _show_dishes(self, category: str = "Все категории") -> None:
        """показать блюда выбранной категории"""
        # тут надо очистить текущие виджеты
        for i in reversed(range(self.dishes_layout.count())):
            widget = self.dishes_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # получаем блюда для отображения
        if category == "Все категории":
            dishes_to_show = self.menu_manager.dishes
        else:
            dishes_to_show = self.menu_manager.get_dishes_by_category(category)

        # создаем виджеты для каждого блюда
        for dish in dishes_to_show:
            dish_widget = DishWidget(dish)
            dish_widget.selection_changed.connect(self._on_dish_selection_changed)
            self.dishes_layout.addWidget(dish_widget)

    def _load_order_history(self) -> None:
        """загрузить историю заказов в таблицу"""
        orders = self.database.get_order_history()
        self.orders_table.setRowCount(len(orders))

        for row, order_data in enumerate(orders):
            self.orders_table.setItem(row, 0, QTableWidgetItem(str(order_data['id'])))
            self.orders_table.setItem(row, 1, QTableWidgetItem(order_data['date']))
            self.orders_table.setItem(row, 2, QTableWidgetItem(str(order_data['item_count'])))
            self.orders_table.setItem(row, 3, QTableWidgetItem(f"{order_data['total_price']:.2f} руб."))
            self.orders_table.setItem(row, 4, QTableWidgetItem(order_data['status']))

    def _connect_signals(self) -> None:
        """подключить сигналы и слоты"""
        self.category_combo.currentTextChanged.connect(self._on_category_changed)
        self.clear_button.clicked.connect(self._clear_selection)
        self.confirm_button.clicked.connect(self._confirm_order)
        self.refresh_button.clicked.connect(self._load_order_history)

        # меню действий
        self.export_action.triggered.connect(self._export_orders)
        self.exit_action.triggered.connect(self.close)
        self.about_action.triggered.connect(self._show_about)

    def _on_category_changed(self, category: str) -> None:
        """лбработчик изменения категории"""
        self._show_dishes(category)

    def _on_dish_selection_changed(self, dish_id: int, is_selected: bool) -> None:
        """обработчик изменения выбора блюда"""
        dish = self.menu_manager.find_dish_by_id(dish_id)
        if dish:
            if is_selected:
                self.order.add_dish(dish)
            else:
                self.order.remove_dish(dish)

            self._update_total_display()

    def _update_total_display(self) -> None:
        """обновить отображение общей суммы"""
        total = self.order.get_total_price()
        self.total_label.setText(f"Итого: {total:.2f} руб.")

        # обновляем статус бар
        dish_count = self.order.get_dish_count()
        self.statusbar.showMessage(f"Выбрано блюд: {dish_count}, Общая сумма: {total:.2f} руб.")

    def _clear_selection(self) -> None:
        """очистить все выбранные блюда"""
        reply = QMessageBox.question(
            self,
            "Очистка выбора",
            "Вы уверены, что хотите очистить все выбранные блюда?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.order.clear_order()
            self._update_total_display()

            # сбрасываем все чекбоксы
            for i in range(self.dishes_layout.count()):
                widget = self.dishes_layout.itemAt(i).widget()
                if isinstance(widget, DishWidget):
                    widget.checkbox.setChecked(False)

    def _confirm_order(self) -> None:
        """подтвердить заказ"""
        if not self.order.selected_dishes:
            QMessageBox.warning(self, "Внимание", "Выберите хотя бы одно блюдо!")
            return

        # показываем диалог подтверждения
        dialog = OrderDialog(self.order, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            try:
                # сохраняем заказ в базу
                order_id = self.database.save_order(
                    self.order.selected_dishes,
                    self.order.get_total_price()
                )

                QMessageBox.information(
                    self,
                    "Заказ подтвержден",
                    f"Заказ №{order_id} успешно сохранен!\n"
                    f"Сумма: {self.order.get_total_price():.2f} руб."
                )

                # очищаем заказ и обновляем интерфейс
                self._clear_selection()
                self._load_order_history()

            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Ошибка",
                    f"Не удалось сохранить заказ: {str(e)}"
                )

    def _export_orders(self) -> None:
        """тут надо экспортировать историю заказов в CSV"""
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Экспорт заказов",
                "orders_export.csv",
                "CSV Files (*.csv)"
            )

            if file_path:
                orders = self.database.get_order_history()
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("ID;Дата;Количество блюд;Сумма;Статус\n")
                    for order_data in orders:
                        f.write(f"{order_data['id']};{order_data['date']};"
                                f"{order_data['item_count']};{order_data['total_price']};"
                                f"{order_data['status']}\n")

                QMessageBox.information(self, "Успех", f"Данные экспортированы в {file_path}")

        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось экспортировать данные: {str(e)}")

    def _show_about(self) -> None:
        """показать информацию о программе"""
        QMessageBox.about(
            self,
            "О программе",
            "Чайхана - высокая кухня!!!!\n\n"
            "Версия 1.0\n"
            "Программа для симуляции выбора блюд и управления заказами.\n\n"
            "Функции:\n"
            "• Просмотр меню по категориям\n"
            "• Выбор блюд с подсчетом суммы\n"
            "• История заказов\n"
            "• Экспорт данных\n"
        )


def main():
    """главная функция приложения"""
    app = QApplication(sys.argv)
    app.setApplicationName("Ресторан - Система заказов")
    app.setApplicationVersion("1.0")

    window = MainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
