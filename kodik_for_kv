import sys
import sqlite3
from dataclasses import dataclass
from typing import List, Optional

from PyQt6 import QtGui
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QCheckBox, QPushButton, QScrollArea,
    QMessageBox, QFileDialog, QComboBox, QTableWidget,
    QTableWidgetItem, QHeaderView, QDialog, QTabWidget,
    QStatusBar, QMenuBar, QMenu, QApplication
)


@dataclass
class Dish:
    """класс, который представляет блюдо"""
    id: int
    name: str
    price: float
    image_path: str
    description: str
    category: str
    is_selected: bool = False


class Order:
    """класс для управления заказом"""

    def __init__(self):
        self.selected_dishes: List[Dish] = []

    def add_dish(self, dish: Dish) -> None:
        """возможность добавить блюдо в заказ"""
        if dish not in self.selected_dishes:
            self.selected_dishes.append(dish)

    def remove_dish(self, dish: Dish) -> None:
        """возможность удалить блюдо из заказа"""
        if dish in self.selected_dishes:
            self.selected_dishes.remove(dish)

    def clear_order(self) -> None:
        """кнопочка очистить заказ"""
        self.selected_dishes.clear()

    def get_total_price(self) -> float:
        """получить общую сумму заказа"""
        return sum(dish.price for dish in self.selected_dishes)

    def get_dish_count(self) -> int:
        """получить количество выбранных блюд"""
        return len(self.selected_dishes)


class MenuManager:
    """менеджер для работы с меню"""

    def __init__(self):
        self.dishes: List[Dish] = []

    def load_dishes_from_database(self, database) -> None:
        """загрузить блюда из базы данных"""
        self.dishes = database.get_all_dishes()

    def get_dishes_by_category(self, category: str) -> List[Dish]:
        """получить блюда по категории"""
        return [dish for dish in self.dishes if dish.category == category]

    def get_categories(self) -> List[str]:
        """получить список категори"""
        return list(set(dish.category for dish in self.dishes))

    def find_dish_by_id(self, dish_id: int) -> Optional[Dish]:
        """найти блюдо по айдишке"""
        for dish in self.dishes:
            if dish.id == dish_id:
                return dish
        return None


class DatabaseManager:
    """менеджер базы данных для приложения"""

    def __init__(self, db_path: str = "restaurant.db"):
        self.db_path = db_path
        self._init_database()

    def _init_database(self) -> None:
        """инициализиую базу данных и создаю таблицы."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # тут табличка категорий
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS categories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    description TEXT
                )
            ''')

            # это таблица блюд
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS dishes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    price REAL NOT NULL,
                    image_path TEXT,
                    description TEXT,
                    category_id INTEGER,
                    FOREIGN KEY (category_id) REFERENCES categories (id)
                )
            ''')

            # а тут таблица заказов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_date TIMESTAMP DEFAULT (datetime('now', 'localtime')),
                    total_price REAL NOT NULL,
                    status TEXT DEFAULT 'pending'
                )
            ''')

            # это таблица элементов заказа
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS order_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id INTEGER,
                    dish_id INTEGER,
                    quantity INTEGER DEFAULT 1,
                    price REAL NOT NULL,
                    FOREIGN KEY (order_id) REFERENCES orders (id),
                    FOREIGN KEY (dish_id) REFERENCES dishes (id)
                )
            ''')

            self._insert_sample_data(cursor)
            conn.commit()

    def _insert_sample_data(self, cursor: sqlite3.Cursor) -> None:
        # тут мы проверяем есть ли уже категории
        cursor.execute("SELECT COUNT(*) FROM categories")
        if cursor.fetchone()[0] == 0:
            categories = [
                ("Основные блюда", "Сытные и питательные блюда"),
                ("Салаты", "Свежие и легкие салаты"),
                ("Напитки", "Освежающие напитки")
            ]
            cursor.executemany(
                "INSERT INTO categories (name, description) VALUES (?, ?)",
                categories
            )

        # а тут проверяем есть ли уже блюда
        cursor.execute("SELECT COUNT(*) FROM dishes")
        if cursor.fetchone()[0] == 0:
            dishes = [
                ("Стейк Рибай", 25.99, "Премиальный стейк с овощами", 1),
                ("Паста Карбонара", 18.50, "Классическая итальянская паста", 1),
                ("Греческий салат", 12.75, "Свежие овощи с фетой", 2),
                ("Цезарь с курицей", 14.25, "Салат Цезарь с куриной грудкой", 2),
                ("Апельсиновый сок", 5.50, "Свежевыжатый апельсиновый сок", 3),
                ("Кофе Латте", 4.75, "Ароматный кофе с молоком", 3)
            ]
            cursor.executemany(
                "INSERT INTO dishes (name, price, image_path, description, category_id) VALUES (?, ?, ?, ?, ?)",
                dishes
            )

    def get_all_dishes(self) -> List[Dish]:
        """получаем все блюда из базы данных"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT d.id, d.name, d.price, d.image_path, d.description, c.name 
                FROM dishes d 
                JOIN categories c ON d.category_id = c.id
            ''')

            dishes = []
            for row in cursor.fetchall():
                dish = Dish(
                    id=row[0],
                    name=row[1],
                    price=row[2],
                    image_path=row[3],
                    description=row[4],
                    category=row[5]
                )
                dishes.append(dish)

            return dishes

    def save_order(self, dishes: List[Dish], total_price: float) -> int:
        """сохранить заказ в базу данных и вернуть ID заказа"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # здесь вставляем основной заказ
            cursor.execute(
                "INSERT INTO orders (total_price) VALUES (?)",
                (total_price,)
            )
            order_id = cursor.lastrowid

            # а тут вставляем элементы заказа
            order_items = [(order_id, dish.id, 1, dish.price) for dish in dishes]
            cursor.executemany(
                "INSERT INTO order_items (order_id, dish_id, quantity, price) VALUES (?, ?, ?, ?)",
                order_items
            )

            conn.commit()
            return order_id

    def get_order_history(self) -> List[dict]:
        """история з@казов"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT o.id, o.order_date, o.total_price, o.status,
                       COUNT(oi.id) as item_count
                FROM orders o
                LEFT JOIN order_items oi ON o.id = oi.order_id
                GROUP BY o.id
                ORDER BY o.order_date DESC
            ''')

            orders = []
            for row in cursor.fetchall():
                orders.append({
                    'id': row[0],
                    'date': row[1],
                    'total_price': row[2],
                    'status': row[3],
                    'item_count': row[4]
                })

            return orders


class DishWidget(QWidget):
    """виджет для отображения блюда"""

    selection_changed = pyqtSignal(int, bool)  # dish_id, is_selected

    def __init__(self, dish: Dish, parent=None):
        super().__init__(parent)
        self.dish = dish
        self._init_ui()

    def _init_ui(self) -> None:
        """инициализируем пользовательский интерфейс"""
        main_layout = QHBoxLayout(self)

        # чекбоксик для выбора блюда
        self.checkbox = QCheckBox()
        self.checkbox.setChecked(self.dish.is_selected)
        self.checkbox.stateChanged.connect(self._on_checkbox_changed)
        main_layout.addWidget(self.checkbox)

        image_container = QWidget()
        image_container.setFixedSize(100, 100)
        image_layout = QVBoxLayout(image_container)

        color_label = QLabel()
        color_label.setFixedSize(80, 80)

        # разные цвета для блюд
        colors = ['#FFE4E1', '#E6E6FA', '#F0FFF0', '#FFF0F5', '#F5F5DC', '#F0F8FF']
        color_index = hash(self.dish.name) % len(colors)
        color_label.setStyleSheet(
            f"background-color: {colors[color_index]}; border: 1px solid #ccc;"
        )
        color_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        color_label.setText(
            self.dish.name[:10] + "..." if len(self.dish.name) > 10 else self.dish.name
        )

        image_layout.addWidget(color_label)
        main_layout.addWidget(image_container)

        # информация о блюде
        info_layout = QVBoxLayout()

        name_label = QLabel(self.dish.name)
        name_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        info_layout.addWidget(name_label)

        desc_label = QLabel(self.dish.description)
        desc_label.setStyleSheet("color: gray; font-size: 12px;")
        desc_label.setWordWrap(True)
        info_layout.addWidget(desc_label)

        price_label = QLabel(f"Цена: {self.dish.price:.2f} руб.")
        price_label.setStyleSheet("color: green; font-weight: bold; font-size: 12px;")
        info_layout.addWidget(price_label)

        info_layout.addStretch()
        main_layout.addLayout(info_layout)

        self.setLayout(main_layout)
        self.setFixedHeight(120)
        self.setStyleSheet("""
            DishWidget {
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 5px;
                margin: 2px;
                background-color: white;
            }
            DishWidget:hover {
                background-color: #f5f5f5;
            }
        """)

    def _on_checkbox_changed(self, state: int) -> None:
        """обработчик изменения состояния чекбокса"""
        is_checked = state == Qt.CheckState.Checked.value
        self.dish.is_selected = is_checked
        self.selection_changed.emit(self.dish.id, is_checked)


class OrderDialog(QDialog):
    """диалоговое окно подтверждения заказа"""

    def __init__(self, order: Order, parent=None):
        super().__init__(parent)
        self.order = order
        self._init_ui()

    def _init_ui(self) -> None:
        """инициализирую пользовательский интерфейс."""
        self.setWindowTitle("Подтверждение заказа")
        self.setFixedSize(400, 300)

        layout = QVBoxLayout(self)

        # заголовок
        title_label = QLabel("Ваш заказ:")
        title_label.setStyleSheet("font-weight: bold; font-size: 16px;")
        layout.addWidget(title_label)

        # список выбранных блюд
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)

        for dish in self.order.selected_dishes:
            dish_layout = QHBoxLayout()
            dish_layout.addWidget(QLabel(f"• {dish.name}"))
            dish_layout.addStretch()
            dish_layout.addWidget(QLabel(f"{dish.price:.2f} руб."))
            scroll_layout.addLayout(dish_layout)

        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        layout.addWidget(scroll_area)

        # итог по сумме
        total_layout = QHBoxLayout()
        total_layout.addWidget(QLabel("Итого:"))
        total_layout.addStretch()
        total_label = QLabel(f"{self.order.get_total_price():.2f} руб.")
        total_label.setStyleSheet("font-weight: bold; color: green;")
        total_layout.addWidget(total_label)
        layout.addLayout(total_layout)

        # кнопочки
        button_layout = QHBoxLayout()

        cancel_button = QPushButton("Отмена")
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)

        confirm_button = QPushButton("Подтвердить")
        confirm_button.clicked.connect(self.accept)
        confirm_button.setStyleSheet("background-color: #4CAF50; color: white;")
        button_layout.addWidget(confirm_button)

        layout.addLayout(button_layout)
        self.setLayout(layout)


# UI класс для загрузки интерфейса
class Ui_MainWindow:
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(900, 700)

        self.centralwidget = QWidget(MainWindow)
        self.verticalLayout = QVBoxLayout(self.centralwidget)

        self.tabWidget = QTabWidget(self.centralwidget)

        # Вкладка меню
        self.menu_tab = QWidget()
        self.menu_layout = QVBoxLayout(self.menu_tab)

        self.category_combo = QComboBox(self.menu_tab)
        self.menu_layout.addWidget(self.category_combo)

        self.scroll_area = QScrollArea(self.menu_tab)
        self.scroll_widget = QWidget()
        self.dishes_layout = QVBoxLayout(self.scroll_widget)
        self.scroll_area.setWidget(self.scroll_widget)
        self.scroll_area.setWidgetResizable(True)
        self.menu_layout.addWidget(self.scroll_area)

        self.control_layout = QHBoxLayout()
        self.clear_button = QPushButton("Очистить выбор", self.menu_tab)
        self.control_layout.addWidget(self.clear_button)
        self.control_layout.addStretch()
        self.total_label = QLabel("Итого: 0.00 руб.", self.menu_tab)
        self.control_layout.addWidget(self.total_label)
        self.confirm_button = QPushButton("Подтвердить заказ", self.menu_tab)
        self.control_layout.addWidget(self.confirm_button)
        self.menu_layout.addLayout(self.control_layout)

        self.tabWidget.addTab(self.menu_tab, "Меню")

        # вкладка истории
        self.history_tab = QWidget()
        self.history_layout = QVBoxLayout(self.history_tab)

        self.orders_table = QTableWidget(self.history_tab)
        self.history_layout.addWidget(self.orders_table)

        self.refresh_button = QPushButton("Обновить", self.history_tab)
        self.history_layout.addWidget(self.refresh_button)

        self.tabWidget.addTab(self.history_tab, "История заказов")

        self.verticalLayout.addWidget(self.tabWidget)
        MainWindow.setCentralWidget(self.centralwidget)

        # staтус бар
        self.statusbar = QStatusBar(MainWindow)
        MainWindow.setStatusBar(self.statusbar)

        # меню
        self.menubar = QMenuBar(MainWindow)
        self.file_menu = QMenu("Файл", self.menubar)
        self.help_menu = QMenu("Справка", self.menubar)

        self.export_action = QtGui.QAction("Экспорт заказов", MainWindow)
        self.exit_action = QtGui.QAction("Выход", MainWindow)
        self.about_action = QtGui.QAction("О программе", MainWindow)

        self.file_menu.addAction(self.export_action)
        self.file_menu.addAction(self.exit_action)
        self.help_menu.addAction(self.about_action)

        self.menubar.addAction(self.file_menu.menuAction())
        self.menubar.addAction(self.help_menu.menuAction())
        MainWindow.setMenuBar(self.menubar)


class MainWindow(QMainWindow, Ui_MainWindow):
    """главное окно приложения"""

    def __init__(self):
        super().__init__()
        self.setupUi(self)

        self.database = DatabaseManager()
        self.menu_manager = MenuManager()
        self.order = Order()

        self._load_data()
        self._setup_ui()
        self._connect_signals()
        self.statusbar.showMessage("Готово к работе")

    def _setup_ui(self) -> None:
        """настроить дополнительные элементы интерфейса"""
        self.orders_table.setColumnCount(5)
        self.orders_table.setHorizontalHeaderLabels([
            "ID", "Дата", "Кол-во блюд", "Сумма", "Статус"
        ])
        self.orders_table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )

    def _load_data(self) -> None:
        """загрузить данные из базы"""
        try:
            self.menu_manager.load_dishes_from_database(self.database)
            self._populate_categories()
            self._show_dishes()
            self._load_order_history()
        except Exception as e:
            QMessageBox.critical(
                self, "Ошибка", f"Не удалось загрузить данные: {str(e)}"
            )

    def _populate_categories(self) -> None:
        """заполнить комбобокс категориями"""
        self.category_combo.clear()
        self.category_combo.addItem("Все категории")

        for category in self.menu_manager.get_categories():
            self.category_combo.addItem(category)

    def _show_dishes(self, category: str = "Все категории") -> None:
        """показать блюда выбранной категории"""
        for i in reversed(range(self.dishes_layout.count())):
            widget = self.dishes_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # получаем блюда для отображения
        if category == "Все категории":
            dishes_to_show = self.menu_manager.dishes
        else:
            dishes_to_show = self.menu_manager.get_dishes_by_category(category)

        # создаем виджеты для каждого блюда
        for dish in dishes_to_show:
            dish_widget = DishWidget(dish)
            dish_widget.selection_changed.connect(self._on_dish_selection_changed)
            self.dishes_layout.addWidget(dish_widget)

    def _load_order_history(self) -> None:
        """загрузить историю заказов в таблицу"""
        orders = self.database.get_order_history()
        self.orders_table.setRowCount(len(orders))

        for row, order_data in enumerate(orders):
            self.orders_table.setItem(
                row, 0, QTableWidgetItem(str(order_data['id']))
            )
            self.orders_table.setItem(
                row, 1, QTableWidgetItem(order_data['date'])
            )
            self.orders_table.setItem(
                row, 2, QTableWidgetItem(str(order_data['item_count']))
            )
            self.orders_table.setItem(
                row, 3, QTableWidgetItem(f"{order_data['total_price']:.2f} руб.")
            )
            self.orders_table.setItem(
                row, 4, QTableWidgetItem(order_data['status'])
            )

    def _connect_signals(self) -> None:
        """подключить сигналы и слоты"""
        self.category_combo.currentTextChanged.connect(self._on_category_changed)
        self.clear_button.clicked.connect(self._clear_selection)
        self.confirm_button.clicked.connect(self._confirm_order)
        self.refresh_button.clicked.connect(self._load_order_history)
        self.export_action.triggered.connect(self._export_orders)
        self.exit_action.triggered.connect(self.close)
        self.about_action.triggered.connect(self._show_about)

    def _on_category_changed(self, category: str) -> None:
        """лбработчик изменения категории"""
        self._show_dishes(category)

    def _on_dish_selection_changed(self, dish_id: int, is_selected: bool) -> None:
        """обработчик изменения выбора блюда"""
        dish = self.menu_manager.find_dish_by_id(dish_id)
        if dish:
            if is_selected:
                self.order.add_dish(dish)
            else:
                self.order.remove_dish(dish)
        self._update_total_display()

    def _update_total_display(self) -> None:
        """обновить отображение общей суммы"""
        total = self.order.get_total_price()
        self.total_label.setText(f"Итого: {total:.2f} руб.")
        dish_count = self.order.get_dish_count()
        self.statusbar.showMessage(
            f"Выбрано блюд: {dish_count}, Общая сумма: {total:.2f} руб."
        )

    def _clear_selection(self) -> None:
        """очистить все выбранные блюда"""
        reply = QMessageBox.question(
            self,
            "Очистка выбора",
            "Вы уверены, что хотите очистить все выбранные блюда?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.order.clear_order()
            self._update_total_display()

            # сбрасываем все чекбоксы
            for i in range(self.dishes_layout.count()):
                widget = self.dishes_layout.itemAt(i).widget()
                if isinstance(widget, DishWidget):
                    widget.checkbox.setChecked(False)

    def _confirm_order(self) -> None:
        """подтвердить заказ"""
        if not self.order.selected_dishes:
            QMessageBox.warning(self, "Внимание", "Выберите хотя бы одно блюдо!")
            return

        # показываем диалог подтверждения
        dialog = OrderDialog(self.order, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            try:
                # сохраняем заказ в базу
                order_id = self.database.save_order(
                    self.order.selected_dishes,
                    self.order.get_total_price()
                )

                QMessageBox.information(
                    self,
                    "Заказ подтвержден",
                    f"Заказ №{order_id} успешно сохранен!\n"
                    f"Сумма: {self.order.get_total_price():.2f} руб."
                )

                # очищаем заказ и обновляем интерфейс
                self._clear_selection()
                self._load_order_history()

            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Ошибка",
                    f"Не удалось сохранить заказ: {str(e)}"
                )

    def _export_orders(self) -> None:
        """экспортировать историю заказиков в csv"""
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Экспорт заказов",
                "orders_export.csv",
                "CSV Files (*.csv)"
            )

            if file_path:
                orders = self.database.get_order_history()
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("ID;Дата;Количество блюд;Сумма;Статус\n")
                    for order_data in orders:
                        f.write(
                            f"{order_data['id']};{order_data['date']};"
                            f"{order_data['item_count']};{order_data['total_price']};"
                            f"{order_data['status']}\n"
                        )

                QMessageBox.information(
                    self, "Успех", f"Данные экспортированы в {file_path}"
                )

        except Exception as e:
            QMessageBox.critical(
                self, "Ошибка", f"Не удалось экспортировать данные: {str(e)}"
            )

    def _show_about(self) -> None:
        """показать информацию о моей программе"""
        QMessageBox.about(
            self,
            "О программе",
            "Чайхана - высокая кухня!!!!\n\n"
            "Версия 1.0\n"
            "Программа для симуляции выбора блюд и управления заказами.\n\n"
            "Функции:\n"
            "• Просмотр меню по категориям\n"
            "• Выбор блюд с подсчетом суммы\n"
            "• История заказов\n"
            "• Экспорт данных\n"
        )


def main():
    """главная функция приложения"""
    app = QApplication(sys.argv)
    app.setApplicationName("Ресторан - Система заказов")
    app.setApplicationVersion("1.0")

    window = MainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
